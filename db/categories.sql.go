// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: categories.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countCategoriesByOwnerID = `-- name: CountCategoriesByOwnerID :one
SELECT COUNT(*) as count FROM categories WHERE owner_id = ?
`

func (q *Queries) CountCategoriesByOwnerID(ctx context.Context, ownerID uint64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCategoriesByOwnerID, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategory = `-- name: CreateCategory :execlastid
INSERT INTO categories (name, owner_id) VALUES (?, ?)
`

type CreateCategoryParams struct {
	Name    string `db:"name" json:"name"`
	OwnerID uint64 `db:"owner_id" json:"owner_id"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createCategory, arg.Name, arg.OwnerID)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createCategoryShare = `-- name: CreateCategoryShare :execlastid

INSERT INTO category_shares (category_id, shared_with_user_id, permission)
VALUES (?, ?, ?)
`

type CreateCategoryShareParams struct {
	CategoryID       uint64                   `db:"category_id" json:"category_id"`
	SharedWithUserID uint64                   `db:"shared_with_user_id" json:"shared_with_user_id"`
	Permission       CategorySharesPermission `db:"permission" json:"permission"`
}

// Category Shares queries
func (q *Queries) CreateCategoryShare(ctx context.Context, arg CreateCategoryShareParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createCategoryShare, arg.CategoryID, arg.SharedWithUserID, arg.Permission)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = ?
`

func (q *Queries) DeleteCategory(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, id)
	return err
}

const deleteCategoryShare = `-- name: DeleteCategoryShare :exec
DELETE FROM category_shares WHERE id = ?
`

func (q *Queries) DeleteCategoryShare(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, deleteCategoryShare, id)
	return err
}

const deleteCategoryShareByUserAndCategory = `-- name: DeleteCategoryShareByUserAndCategory :exec
DELETE FROM category_shares WHERE category_id = ? AND shared_with_user_id = ?
`

type DeleteCategoryShareByUserAndCategoryParams struct {
	CategoryID       uint64 `db:"category_id" json:"category_id"`
	SharedWithUserID uint64 `db:"shared_with_user_id" json:"shared_with_user_id"`
}

func (q *Queries) DeleteCategoryShareByUserAndCategory(ctx context.Context, arg DeleteCategoryShareByUserAndCategoryParams) error {
	_, err := q.db.ExecContext(ctx, deleteCategoryShareByUserAndCategory, arg.CategoryID, arg.SharedWithUserID)
	return err
}

const getCategoriesByOwnerID = `-- name: GetCategoriesByOwnerID :many
SELECT id, name, owner_id, created_at, updated_at
FROM categories
WHERE owner_id = ?
ORDER BY name ASC
`

func (q *Queries) GetCategoriesByOwnerID(ctx context.Context, ownerID uint64) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, getCategoriesByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, owner_id, created_at, updated_at
FROM categories
WHERE id = ?
`

func (q *Queries) GetCategoryByID(ctx context.Context, id uint64) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryByNameAndOwner = `-- name: GetCategoryByNameAndOwner :one
SELECT id, name, owner_id, created_at, updated_at
FROM categories
WHERE owner_id = ? AND name = ?
`

type GetCategoryByNameAndOwnerParams struct {
	OwnerID uint64 `db:"owner_id" json:"owner_id"`
	Name    string `db:"name" json:"name"`
}

func (q *Queries) GetCategoryByNameAndOwner(ctx context.Context, arg GetCategoryByNameAndOwnerParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategoryByNameAndOwner, arg.OwnerID, arg.Name)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryShareByCategoryAndUser = `-- name: GetCategoryShareByCategoryAndUser :one
SELECT id, category_id, shared_with_user_id, permission, created_at
FROM category_shares
WHERE category_id = ? AND shared_with_user_id = ?
`

type GetCategoryShareByCategoryAndUserParams struct {
	CategoryID       uint64 `db:"category_id" json:"category_id"`
	SharedWithUserID uint64 `db:"shared_with_user_id" json:"shared_with_user_id"`
}

func (q *Queries) GetCategoryShareByCategoryAndUser(ctx context.Context, arg GetCategoryShareByCategoryAndUserParams) (CategoryShare, error) {
	row := q.db.QueryRowContext(ctx, getCategoryShareByCategoryAndUser, arg.CategoryID, arg.SharedWithUserID)
	var i CategoryShare
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.SharedWithUserID,
		&i.Permission,
		&i.CreatedAt,
	)
	return i, err
}

const getCategoryShareByID = `-- name: GetCategoryShareByID :one
SELECT id, category_id, shared_with_user_id, permission, created_at
FROM category_shares
WHERE id = ?
`

func (q *Queries) GetCategoryShareByID(ctx context.Context, id uint64) (CategoryShare, error) {
	row := q.db.QueryRowContext(ctx, getCategoryShareByID, id)
	var i CategoryShare
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.SharedWithUserID,
		&i.Permission,
		&i.CreatedAt,
	)
	return i, err
}

const getSharedCategoriesForUser = `-- name: GetSharedCategoriesForUser :many
SELECT c.id, c.name, c.owner_id, c.created_at, c.updated_at,
       cs.permission,
       u.name as owner_name, u.email as owner_email
FROM category_shares cs
JOIN categories c ON cs.category_id = c.id
JOIN users u ON c.owner_id = u.id
WHERE cs.shared_with_user_id = ?
ORDER BY c.name ASC
`

type GetSharedCategoriesForUserRow struct {
	ID         uint64                   `db:"id" json:"id"`
	Name       string                   `db:"name" json:"name"`
	OwnerID    uint64                   `db:"owner_id" json:"owner_id"`
	CreatedAt  time.Time                `db:"created_at" json:"created_at"`
	UpdatedAt  time.Time                `db:"updated_at" json:"updated_at"`
	Permission CategorySharesPermission `db:"permission" json:"permission"`
	OwnerName  string                   `db:"owner_name" json:"owner_name"`
	OwnerEmail string                   `db:"owner_email" json:"owner_email"`
}

func (q *Queries) GetSharedCategoriesForUser(ctx context.Context, sharedWithUserID uint64) ([]GetSharedCategoriesForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getSharedCategoriesForUser, sharedWithUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharedCategoriesForUserRow
	for rows.Next() {
		var i GetSharedCategoriesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Permission,
			&i.OwnerName,
			&i.OwnerEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharesForCategory = `-- name: GetSharesForCategory :many
SELECT cs.id, cs.category_id, cs.shared_with_user_id, cs.permission, cs.created_at,
       u.name as shared_with_user_name, u.email as shared_with_user_email
FROM category_shares cs
JOIN users u ON cs.shared_with_user_id = u.id
WHERE cs.category_id = ?
ORDER BY cs.created_at DESC
`

type GetSharesForCategoryRow struct {
	ID                  uint64                   `db:"id" json:"id"`
	CategoryID          uint64                   `db:"category_id" json:"category_id"`
	SharedWithUserID    uint64                   `db:"shared_with_user_id" json:"shared_with_user_id"`
	Permission          CategorySharesPermission `db:"permission" json:"permission"`
	CreatedAt           time.Time                `db:"created_at" json:"created_at"`
	SharedWithUserName  string                   `db:"shared_with_user_name" json:"shared_with_user_name"`
	SharedWithUserEmail string                   `db:"shared_with_user_email" json:"shared_with_user_email"`
}

func (q *Queries) GetSharesForCategory(ctx context.Context, categoryID uint64) ([]GetSharesForCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getSharesForCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharesForCategoryRow
	for rows.Next() {
		var i GetSharesForCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.SharedWithUserID,
			&i.Permission,
			&i.CreatedAt,
			&i.SharedWithUserName,
			&i.SharedWithUserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodosGroupedByCategory = `-- name: GetTodosGroupedByCategory :many
SELECT
    c.id as category_id,
    c.name as category_name,
    c.owner_id as category_owner_id,
    owner.name as category_owner_name,
    COALESCE(cs.permission, '') as share_permission,
    CASE
        WHEN c.owner_id = ? THEN 'owner'
        ELSE cs.permission
    END as user_permission,
    COALESCE(t.id, 0) as todo_id,
    COALESCE(t.title, '') as todo_title,
    COALESCE(t.description, '') as todo_description,
    COALESCE(t.completed, FALSE) as todo_completed,
    COALESCE(t.created_by, 0) as todo_created_by,
    COALESCE(creator.name, '') as todo_creator_name,
    t.created_at as todo_created_at,
    t.updated_at as todo_updated_at
FROM categories c
LEFT JOIN category_shares cs ON c.id = cs.category_id AND cs.shared_with_user_id = ?
LEFT JOIN todos t ON c.id = t.category_id AND t.deleted_at IS NULL
LEFT JOIN users owner ON c.owner_id = owner.id
LEFT JOIN users creator ON t.created_by = creator.id
WHERE
    c.owner_id = ?
    OR cs.shared_with_user_id = ?
ORDER BY c.name ASC, t.created_at DESC
`

type GetTodosGroupedByCategoryParams struct {
	OwnerID            uint64 `db:"owner_id" json:"owner_id"`
	SharedWithUserID   uint64 `db:"shared_with_user_id" json:"shared_with_user_id"`
	OwnerID_2          uint64 `db:"owner_id_2" json:"owner_id_2"`
	SharedWithUserID_2 uint64 `db:"shared_with_user_id_2" json:"shared_with_user_id_2"`
}

type GetTodosGroupedByCategoryRow struct {
	CategoryID        uint64                   `db:"category_id" json:"category_id"`
	CategoryName      string                   `db:"category_name" json:"category_name"`
	CategoryOwnerID   uint64                   `db:"category_owner_id" json:"category_owner_id"`
	CategoryOwnerName sql.NullString           `db:"category_owner_name" json:"category_owner_name"`
	SharePermission   CategorySharesPermission `db:"share_permission" json:"share_permission"`
	UserPermission    interface{}              `db:"user_permission" json:"user_permission"`
	TodoID            uint64                   `db:"todo_id" json:"todo_id"`
	TodoTitle         string                   `db:"todo_title" json:"todo_title"`
	TodoDescription   string                   `db:"todo_description" json:"todo_description"`
	TodoCompleted     bool                     `db:"todo_completed" json:"todo_completed"`
	TodoCreatedBy     uint64                   `db:"todo_created_by" json:"todo_created_by"`
	TodoCreatorName   string                   `db:"todo_creator_name" json:"todo_creator_name"`
	TodoCreatedAt     sql.NullTime             `db:"todo_created_at" json:"todo_created_at"`
	TodoUpdatedAt     sql.NullTime             `db:"todo_updated_at" json:"todo_updated_at"`
}

// Returns all accessible categories with their todos for a user
// Categories are accessible if user owns them OR they are shared with user
func (q *Queries) GetTodosGroupedByCategory(ctx context.Context, arg GetTodosGroupedByCategoryParams) ([]GetTodosGroupedByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getTodosGroupedByCategory,
		arg.OwnerID,
		arg.SharedWithUserID,
		arg.OwnerID_2,
		arg.SharedWithUserID_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTodosGroupedByCategoryRow
	for rows.Next() {
		var i GetTodosGroupedByCategoryRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryName,
			&i.CategoryOwnerID,
			&i.CategoryOwnerName,
			&i.SharePermission,
			&i.UserPermission,
			&i.TodoID,
			&i.TodoTitle,
			&i.TodoDescription,
			&i.TodoCompleted,
			&i.TodoCreatedBy,
			&i.TodoCreatorName,
			&i.TodoCreatedAt,
			&i.TodoUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissionForCategory = `-- name: GetUserPermissionForCategory :one
SELECT
    CASE
        WHEN c.owner_id = ? THEN 'owner'
        ELSE COALESCE(cs.permission, 'none')
    END as permission
FROM categories c
LEFT JOIN category_shares cs ON c.id = cs.category_id AND cs.shared_with_user_id = ?
WHERE c.id = ?
`

type GetUserPermissionForCategoryParams struct {
	OwnerID          uint64 `db:"owner_id" json:"owner_id"`
	SharedWithUserID uint64 `db:"shared_with_user_id" json:"shared_with_user_id"`
	ID               uint64 `db:"id" json:"id"`
}

func (q *Queries) GetUserPermissionForCategory(ctx context.Context, arg GetUserPermissionForCategoryParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getUserPermissionForCategory, arg.OwnerID, arg.SharedWithUserID, arg.ID)
	var permission interface{}
	err := row.Scan(&permission)
	return permission, err
}

const updateCategory = `-- name: UpdateCategory :exec
UPDATE categories SET name = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateCategoryParams struct {
	Name string `db:"name" json:"name"`
	ID   uint64 `db:"id" json:"id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateCategory, arg.Name, arg.ID)
	return err
}

const updateCategorySharePermission = `-- name: UpdateCategorySharePermission :exec
UPDATE category_shares SET permission = ? WHERE id = ?
`

type UpdateCategorySharePermissionParams struct {
	Permission CategorySharesPermission `db:"permission" json:"permission"`
	ID         uint64                   `db:"id" json:"id"`
}

func (q *Queries) UpdateCategorySharePermission(ctx context.Context, arg UpdateCategorySharePermissionParams) error {
	_, err := q.db.ExecContext(ctx, updateCategorySharePermission, arg.Permission, arg.ID)
	return err
}
